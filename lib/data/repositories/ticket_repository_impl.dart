import 'package:dartz/dartz.dart';
import '../../core/errors/exceptions.dart';
import '../../core/errors/failures.dart';
import '../../domain/entities/ticket.dart';
import '../../domain/repositories/ticket_repository.dart';
import '../datasources/remote/ticket_remote_datasource.dart';
import '../models/ticket_model.dart';

/// Ticket repository implementation
class TicketRepositoryImpl implements TicketRepository {
  final TicketRemoteDataSource remoteDataSource;

  TicketRepositoryImpl({required this.remoteDataSource});

  @override
  Future<Either<Failure, List<TicketType>>> getTicketTypes(String eventId) async {
    try {
      final models = await remoteDataSource.getTicketTypes(eventId);
      return Right(models.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, TicketType>> getTicketType(String id) async {
    try {
      final model = await remoteDataSource.getTicketType(id);
      return Right(model.toEntity());
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message, code: e.code));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, TicketType>> createTicketType(TicketType ticketType) async {
    try {
      final model = TicketTypeModel.fromEntity(ticketType);
      final createdModel = await remoteDataSource.createTicketType(model);
      return Right(createdModel.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } on ValidationException catch (e) {
      return Left(ValidationFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, TicketType>> updateTicketType(TicketType ticketType) async {
    try {
      final model = TicketTypeModel.fromEntity(ticketType);
      final updatedModel = await remoteDataSource.updateTicketType(model);
      return Right(updatedModel.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } on ValidationException catch (e) {
      return Left(ValidationFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteTicketType(String id) async {
    try {
      await remoteDataSource.deleteTicketType(id);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, TicketOrder>> purchaseTickets({
    required String eventId,
    required String ticketTypeId,
    required int quantity,
    required String buyerId,
    required String buyerEmail,
    String? buyerPhone,
    String? promoCode,
    int karmaUsed = 0,
  }) async {
    try {
      // First, get ticket type to calculate pricing
      final ticketTypeModel = await remoteDataSource.getTicketType(ticketTypeId);
      final ticketType = ticketTypeModel.toEntity();

      // Calculate total amount
      final subtotal = ticketType.price * quantity;
      // TODO: Apply promo code discount if applicable
      final totalAmount = subtotal;

      // Create order
      final orderModel = TicketOrderModel(
        id: '', // Will be generated by database
        eventId: eventId,
        ticketTypeId: ticketTypeId,
        buyerId: buyerId,
        buyerEmail: buyerEmail,
        buyerPhone: buyerPhone,
        quantity: quantity,
        unitPrice: ticketType.price,
        subtotal: subtotal,
        discount: 0.0,
        taxAmount: 0.0,
        serviceFee: 0.0,
        totalAmount: totalAmount,
        currency: ticketType.currency,
        status: 'pending',
        paymentIntentId: null,
        paymentMethod: null,
        paidAt: null,
        promoCode: promoCode,
        karmaPointsUsed: karmaUsed,
        metadata: {},
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final createdOrder = await remoteDataSource.createOrder(orderModel);
      return Right(createdOrder.toEntity());
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message, code: e.code));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } on ValidationException catch (e) {
      return Left(ValidationFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, TicketOrder>> getTicketOrder(String orderId) async {
    try {
      final model = await remoteDataSource.getOrder(orderId);
      return Right(model.toEntity());
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message, code: e.code));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<TicketOrder>>> getMyOrders(String userId) async {
    try {
      final models = await remoteDataSource.getOrdersByUser(userId);
      return Right(models.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<Ticket>>> getOrderTickets(String orderId) async {
    try {
      final models = await remoteDataSource.getOrderTickets(orderId);
      return Right(models.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<Ticket>>> getMyTickets(String userId) async {
    try {
      final models = await remoteDataSource.getUserTickets(userId);
      return Right(models.map((model) => model.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Ticket>> getTicket(String ticketId) async {
    try {
      final model = await remoteDataSource.getTicket(ticketId);
      return Right(model.toEntity());
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message, code: e.code));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Ticket>> getTicketByQRCode(String qrCode) async {
    try {
      final model = await remoteDataSource.getTicketByQRCode(qrCode);
      return Right(model.toEntity());
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message, code: e.code));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Ticket>> checkInTicket({
    required String qrCode,
    required String validatorId,
    String? location,
  }) async {
    try {
      // First get the ticket by QR code to get the ticket ID
      final ticketModel = await remoteDataSource.getTicketByQRCode(qrCode);

      // Check if already checked in
      if (ticketModel.isCheckedIn) {
        return Left(ValidationFailure(
          message: 'Ticket has already been checked in',
        ));
      }

      // Perform check-in
      final checkedInModel = await remoteDataSource.checkInTicket(
        ticketModel.id,
        validatorId,
        location,
      );

      return Right(checkedInModel.toEntity());
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message, code: e.code));
    } on ValidationException catch (e) {
      return Left(ValidationFailure(message: e.message, code: e.code));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Ticket>> transferTicket({
    required String ticketId,
    required String fromUserId,
    required String toUserId,
    required String toEmail,
  }) async {
    try {
      // Verify the ticket belongs to fromUserId
      final ticketModel = await remoteDataSource.getTicket(ticketId);

      if (ticketModel.assignedToId != fromUserId) {
        return Left(ValidationFailure(
          message: 'You do not own this ticket',
        ));
      }

      if (ticketModel.isCheckedIn) {
        return Left(ValidationFailure(
          message: 'Cannot transfer a checked-in ticket',
        ));
      }

      final transferredModel = await remoteDataSource.transferTicket(
        ticketId,
        toUserId,
        toEmail,
      );

      return Right(transferredModel.toEntity());
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message, code: e.code));
    } on ValidationException catch (e) {
      return Left(ValidationFailure(message: e.message, code: e.code));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> cancelOrder(String orderId) async {
    try {
      await remoteDataSource.updateOrderStatus(orderId, 'cancelled');
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> requestRefund(String orderId, String reason) async {
    try {
      // Update order status to refund_requested
      // TODO: Store refund reason in metadata or separate table
      await remoteDataSource.updateOrderStatus(orderId, 'refund_requested');
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message, code: e.code));
    } on NetworkException catch (e) {
      return Left(NetworkFailure(message: e.message, code: e.code));
    } catch (e) {
      return Left(GenericFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Map<String, dynamic>>> getTicketSales(String eventId) async {
    // TODO: Implement ticket sales aggregation
    // This should return sales statistics for an event including:
    // - Total tickets sold
    // - Total revenue
    // - Sales by ticket type
    // - Sales over time
    // - Check-in statistics
    return Left(GenericFailure(message: 'Not yet implemented'));
  }
}
